import os
import pickle
from Bio import SeqIO
from pyteomics import parser
import numpy as np
import logging
import config
from dataclasses import dataclass
import re

logger = logging.getLogger(__name__)
_mod_prog = re.compile('\(\w+\)')
accession_id_delim = ';'


def drop_modification(aa_string):
    return _mod_prog.sub("", aa_string)


def compute_peptide_mass(peptide: list):
    """

    :param peptide: list of aa
    :return: peptide neutral mass
    """

    peptide_neutral_mass = config.mass_N_terminus + config.mass_C_terminus
    peptide_mass_l = peptide_neutral_mass
    peptide_mass_u = peptide_neutral_mass

    for aa in peptide:
        peptide_neutral_mass += config.mass_AA[aa]
        peptide_mass_l += config.mass_AA[aa]
        peptide_mass_u += config.mass_AA[aa]
        if aa in config.var_mod_dict:
            mod_masses = [config.mass_AA[config.var_mod_dict[aa]], 0.]
            min_mass = min(mod_masses)
            max_mass = max(mod_masses)
            peptide_mass_l += min_mass
            peptide_mass_u += max_mass
    return peptide_neutral_mass, peptide_mass_l, peptide_mass_u


def compute_neutral_peptide_mass(peptide: list):
    peptide_neutral_mass = config.mass_N_terminus + config.mass_C_terminus
    for aa in peptide:
        peptide_neutral_mass += config.mass_AA[aa]
    return peptide_neutral_mass


@dataclass
class PeptideCandidate:
    seq: list
    mass: float
    ppm: float
    num_var_mod: int
    accession_id: str
    for_dist: bool = False  # whether from the fasta file (False) or
    # generated by the program (True) to compute distribution of mu/sigma


def get_num_var_mod(peptide: list) -> int:
    num_var_mod = 0
    for var_mod_name in config.var_mod_dict.values():
        for aa in peptide:
            if aa == var_mod_name:
                num_var_mod += 1
    return num_var_mod


class DataBaseSearcher(object):
    """
    Base class for search peptides in a db
    """

    def __init__(self, db_fasta_file):
        self.db_fasta_file = db_fasta_file
        self.cleavage_rule = config.cleavage_rule
        self.num_missed_cleavage = config.num_missed_cleavage
        self.max_num_mod = config.max_num_mod
        self.precursor_mass_ppm = config.db_ppm_tolenrance

        logger.info("DataBaseSearcher.__init__(): db_fasta_file = {0:s}".format(self.db_fasta_file))
        logger.info("DataBaseSearcher.__init__(): cleavage_rule = {0:s}".format(self.cleavage_rule))
        logger.info("DataBaseSearcher.__init__(): num_missed_cleavage = {0:d}".format(self.num_missed_cleavage))
        logger.info("DataBaseSearcher.__init__(): num_mod = {0}".format(self.max_num_mod))
        logger.info("DataBaseSearcher.__init__(): precursor_mass_ppm = {0:.6f}".format(self.precursor_mass_ppm))

        self.peptide_count = None
        self.peptide_list = None
        self.peptide_mass_array = None
        self.pepmod_maxmass_array = None
        self.peptide_2_protein_id = None

        self.build_db()

    @staticmethod
    def semi_digest(peptide):
        length = len(peptide)
        if length <= 6:
            return [peptide]
        result = [peptide]
        for i in range(length - 6):
            result.append(peptide[i + 1:])
            result.append(peptide[:(length - i - 1)])
        return result

    # TODO: use a more efficent way to do database search
    def build_db(self):
        """
        :return:
        """

        logger.info("DataBaseSearcher.build_db(): build_db()")
        fix_mod = "fix_" + '_'.join([str(x) for x in config.fix_mod_dict.keys()])
        var_mod = "_var_" + '_'.join([str(x) for x in config.var_mod_dict.keys()])
        peptide_db_file = self.db_fasta_file + '.peptide.' + fix_mod + var_mod + '.dnv2' + '.pkl'
        if os.path.exists(peptide_db_file):
            with open(peptide_db_file, 'rb') as f:
                (self.peptide_count,
                 self.peptide_list,
                 self.peptide_mass_array,
                 self.pepmod_maxmass_array,
                 self.peptide_2_protein_id) = pickle.load(f)
            logger.info("DataBaseSearcher.build_db(): read peptide data base from {}".format(peptide_db_file))
        else:
            logger.info("DataBaseSearcher.build_db(): build peptide data base "
                         "from protein data base {}".format(self.db_fasta_file))
            # parse the input fasta file into a list of sequences
            # more about SeqIO and SeqRecord: http://biopython.org/wiki/SeqRecord
            with open(self.db_fasta_file, "r") as handle:
                record_iterator = SeqIO.parse(handle, "fasta")
                record_list = list(record_iterator)
                logger.info("DataBaseSearcher.build_db(): Number of protein sequences: {0:d}".format(len(record_list)))

            # cleave protein sequences into a list of unique peptides
            # more about pyteomics.parser.cleave and cleavage rules:
            # https://pythonhosted.org/pyteomics/api/parser.html

            # create a peptide to protein accession id map.
            # keys here are all out of modification.
            peptide_2_protein_id = {}
            for record in record_list:
                protein_sequence = str(record.seq)
                protein_id = str(record.id)
                cleaved_peptide_set = parser.cleave(
                    sequence=protein_sequence,
                    rule=parser.expasy_rules[self.cleavage_rule],
                    missed_cleavages=self.num_missed_cleavage)
                for peptide in cleaved_peptide_set:
                    # semi cleavage
                    if config.semi_cleavage:
                        for semi_digested_peptide in self.semi_digest(peptide):
                            if any(x in semi_digested_peptide for x in ['X', 'B', 'U', 'Z']):
                                # skip peptides with undetermined amino acid ['X', 'B', 'U', 'Z']
                                continue
                            if semi_digested_peptide not in peptide_2_protein_id:
                                peptide_2_protein_id[semi_digested_peptide] = {protein_id}
                            else:
                                peptide_2_protein_id[semi_digested_peptide].add(protein_id)
                    else:
                        if any(x in peptide for x in ['X', 'B', 'U', 'Z']):
                            # skip peptides with undetermined amino acid ['X', 'B', 'U', 'Z']
                            continue
                        if peptide not in peptide_2_protein_id:
                            peptide_2_protein_id[peptide] = {protein_id}
                        else:
                            peptide_2_protein_id[peptide].add(protein_id)

            peptide_list = [list(peptide) for peptide in peptide_2_protein_id.keys()]
            peptide_list = [config.fix_mod_peptide_transform(peptide) for peptide in peptide_list]

            peptide_count = len(peptide_list)

            # for each peptide, find the mass and the max modification mass
            peptide_mass_array = np.zeros(peptide_count)
            pepmod_maxmass_array = np.zeros(peptide_count)
            for index, peptide in enumerate(peptide_list):
                neutral_mass, mass_l, mass_u = compute_peptide_mass(peptide)
                peptide_mass_array[index] = neutral_mass
                pepmod_maxmass_array[index] = mass_u

            self.peptide_count = peptide_count
            self.peptide_list = peptide_list
            self.peptide_mass_array = peptide_mass_array
            self.pepmod_maxmass_array = pepmod_maxmass_array
            self.peptide_2_protein_id = peptide_2_protein_id
            with open(peptide_db_file, 'wb') as f:
                data = (self.peptide_count,
                        self.peptide_list,
                        self.peptide_mass_array,
                        self.pepmod_maxmass_array,
                        self.peptide_2_protein_id)
                pickle.dump(data, f)
        logger.info("DataBaseSearcher.build_db(): Number of peptides: {0:d}".format(self.peptide_count))

    def search_peptide_by_mass(self, precursor_mass: float, pad_with_random_permutation=False)->list:
        """
        :param precursor_mass: should be theoretical neutral mass
        :return: a list of peptides
        """
        var_mod_peptide_transform = config.var_mod_peptide_transform
        precursor_mass_tolerance = self.precursor_mass_ppm * precursor_mass * 1e-6

        # 1st filter by the peptide mass and the max pepmod mass
        filter1_index = np.flatnonzero(np.logical_and(
            np.less_equal(self.peptide_mass_array,
                          precursor_mass + precursor_mass_tolerance),
            np.greater_equal(self.pepmod_maxmass_array,
                             precursor_mass - precursor_mass_tolerance)))

        # find all possible modifications
        pepmod_list = []
        for index in filter1_index:
            peptide = self.peptide_list[index]
            pepmod_list += [peptide]
            pepmod_list += var_mod_peptide_transform(peptide)
        pepmod_mass_array = np.array([compute_neutral_peptide_mass(pepmod)
                                      for pepmod in pepmod_list])

        # 2nd filter by exact pepmod mass
        filter2_index = np.flatnonzero(np.logical_and(
            np.less_equal(pepmod_mass_array,
                          precursor_mass + precursor_mass_tolerance),
            np.greater_equal(pepmod_mass_array,
                             precursor_mass - precursor_mass_tolerance)))

        candidate_list = []
        for x in filter2_index:
            theoretical_mass = pepmod_mass_array[x]
            seq = pepmod_list[x]
            drop_mod_seq_string = ''.join([drop_modification(aa) for aa in seq])
            accession_id = accession_id_delim.join(list(self.peptide_2_protein_id[drop_mod_seq_string]))
            ppm = (precursor_mass - theoretical_mass) / theoretical_mass * 1e6
            num_var_mod = get_num_var_mod(seq)
            # filter based on seq length
            if len(seq) > config.MAX_LEN - 2:
                continue
            pc = PeptideCandidate(
                seq=seq,
                mass=theoretical_mass,
                ppm=ppm,
                num_var_mod=num_var_mod,
                accession_id=accession_id
            )
            candidate_list.append(pc)
        if pad_with_random_permutation:
            if len(candidate_list) == 0:
                return []
            elif len(candidate_list) > config.normalizing_std_n:
                return candidate_list
            else:
                # if not enought candidate found, include some random permutation samples so that
                # in total we have more than 150 candidate peptides.
                num_to_generate = config.normalizing_std_n - len(candidate_list)
                selected_pc_list = np.random.choice(candidate_list, size=num_to_generate, replace=True)
                random_neg_pc_list = []
                for pc in selected_pc_list:
                    new_seq = list(np.random.permutation(pc.seq))
                    new_pc = PeptideCandidate(
                        seq=new_seq,
                        mass=pc.mass,
                        ppm=pc.ppm,
                        num_var_mod=pc.num_var_mod,
                        accession_id=pc.accession_id,
                        for_dist=True,
                    )
                    random_neg_pc_list.append(new_pc)
                return candidate_list + random_neg_pc_list
        return candidate_list
